<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Image Processing on Claudio Mandelli</title><link>https://cmanziel.github.io/categories/image-processing/</link><description>Recent content in Image Processing on Claudio Mandelli</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://cmanziel.github.io/categories/image-processing/index.xml" rel="self" type="application/rss+xml"/><item><title>ImageEditor</title><link>https://cmanziel.github.io/p/imageeditor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cmanziel.github.io/p/imageeditor/</guid><description>&lt;img src="https://cmanziel.github.io/p/imageeditor/collage.png" alt="Featured image of post ImageEditor" />&lt;p>This project combines two other ones i made before.
One is about drawing on a window using the mouse cursor as a brush, the other is the pnglib library to convert into an image what&amp;rsquo;s been drawn on the window. &lt;a class="link" href="https://github.com/cmanziel/ImageEditor" target="_blank" rel="noopener"
>Source code&lt;/a>.&lt;/p>
&lt;h2 id="window">Window
&lt;/h2>&lt;p>The window is conceptually divided into a grid of pixels, whose data is stored in a bi-dimensional array of &lt;em>point&lt;/em> structures.
The image pixels are mapped 1:1 to the window pixels.
The window creation is done through GLFW.&lt;/p>
&lt;h2 id="image-decompression">Image Decompression
&lt;/h2>&lt;p>To edit the image it has to be firstly displayed onto the window.
To do so the image has to be decompressed to get the raw pixel data containing the rgb values for each pixel.
The decompression is handled by the &lt;em>pnglib&lt;/em> library: its &lt;em>decompress&lt;/em> function receives the image file and returns its pixel data.
If no image is provided or the file is corrupted a default white color is applied to every pixel&lt;/p>
&lt;h2 id="brush">Brush
&lt;/h2>&lt;p>A brush is constructed around the mouse cursor as a circular grid.
The center of the grid is the pixel the cursor is currently pointing.
Its dimensions can vary on mouse input or based on the cursor&amp;rsquo;s speed as selected by the user.
Handled by the Brush class.&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/imageeditor/drawing_site.jpg"
width="400"
height="200"
srcset="https://cmanziel.github.io/p/imageeditor/drawing_site_hu846adc7727ddfebc847a463b16f7955f_53634_480x0_resize_q75_box.jpg 480w, https://cmanziel.github.io/p/imageeditor/drawing_site_hu846adc7727ddfebc847a463b16f7955f_53634_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
alt="Drawing before the brush implementation: the cursor colors only the pixel at its position."
class="gallery-image"
data-flex-grow="200"
data-flex-basis="480px"
>&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/imageeditor/drawing_0_site.jpg"
width="2000"
height="1000"
srcset="https://cmanziel.github.io/p/imageeditor/drawing_0_site_hu9e753b070ffddff79c3aeaf23097fd11_119139_480x0_resize_q75_box.jpg 480w, https://cmanziel.github.io/p/imageeditor/drawing_0_site_hu9e753b070ffddff79c3aeaf23097fd11_119139_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
alt="Brush implemented as a square grid. Its dimension is modified through key input."
class="gallery-image"
data-flex-grow="200"
data-flex-basis="480px"
>&lt;/p>
&lt;h2 id="pointbuffer">PointBuffer
&lt;/h2>&lt;p>This is the class that actually handles the window&amp;rsquo;s grid allocation in memory and modifies its values.
The functions &lt;em>InsertPoint&lt;/em> and &lt;em>RemovePoint&lt;/em> use the brush&amp;rsquo;s position and dimension to draw the correct points on the image.&lt;/p>
&lt;h2 id="image-generation">Image Generation
&lt;/h2>&lt;p>The initial image&amp;rsquo;s pixel data is overwritten by what&amp;rsquo;s drawn onto it.
The window&amp;rsquo;s bi-dimensional grid array serves as the raw pixel data input for the &lt;em>compress&lt;/em> function of the &lt;em>pnglib&lt;/em> library.
A PNG file is written from scratch by the library inserting the compressed pixel data into it.&lt;/p>
&lt;p>&lt;img src="https://cmanziel.github.io/p/imageeditor/collage.png"
width="1920"
height="1920"
srcset="https://cmanziel.github.io/p/imageeditor/collage_huf99be8e24da03c81da2c64a7fd101c8a_594606_480x0_resize_box_3.png 480w, https://cmanziel.github.io/p/imageeditor/collage_huf99be8e24da03c81da2c64a7fd101c8a_594606_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Drawing on images previously generated by this application. Brush implemented as a circular grid."
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
>&lt;/p>
&lt;!-- ## Syntax
```markdown
![Image 1](1.jpg) ![Image 2](2.jpg)
```
## Result
![Image 1](1.jpg) ![Image 2](2.jpg)
> Photo by [mymind](https://unsplash.com/@mymind) and [Luke Chesser](https://unsplash.com/@lukechesser) on [Unsplash](https://unsplash.com/) --></description></item><item><title>pnglib</title><link>https://cmanziel.github.io/p/pnglib/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cmanziel.github.io/p/pnglib/</guid><description>&lt;img src="https://cmanziel.github.io/p/pnglib/cover.jpg" alt="Featured image of post pnglib" />&lt;p>Static library to encode or decode PNG files by compressing data into zlib datastreams or decompressing from them.
The aim of this project was to generate an uncorrupted PNG file from scratch. &lt;a class="link" href="https://github.com/cmanziel/pnglib" target="_blank" rel="noopener"
>Source code&lt;/a>.&lt;/p>
&lt;h2 id="png-file-structure">PNG file structure
&lt;/h2>&lt;p>According to the &lt;a class="link" href="https://www.w3.org/TR/png-3" target="_blank" rel="noopener"
>PNG specification&lt;/a> a PNG file has to contain at least each one of these chunks of data:&lt;/p>
&lt;h3 id="ihdr">IHDR
&lt;/h3>&lt;p>This is the image header chunk. It contains general information about the image like width, height, pixel data length and format and an 8-byte signature that every PNG file contains.&lt;/p>
&lt;h3 id="idat">IDAT
&lt;/h3>&lt;p>This is the chunk that contains the actual image pixel data. The original raw data, stored in the format indicated in the IHDR chunk, has to be compressed through the zlib library&amp;rsquo;s DEFLATE routine and put into one or multiple IDAT chunks one after each other. An incorrect zlib&amp;rsquo;s datastream will result in a corrupted PNG file.&lt;/p>
&lt;h3 id="iend">IEND
&lt;/h3>&lt;p>Chunk at the end of the image file.&lt;/p>
&lt;h2 id="image-encoding">Image Encoding
&lt;/h2>&lt;p>Each chunk consists of three or four fields:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Length&lt;/strong>: A four-byte unsigned integer giving the number of bytes in the chunk&amp;rsquo;s &lt;em>data&lt;/em> field.&lt;/li>
&lt;li>&lt;strong>Chunk type&lt;/strong>: The data bytes appropriate to the chunk type, if any. This field can be of zero length.&lt;/li>
&lt;li>&lt;strong>Chunk data&lt;/strong>: the actual data for the chunk in use&lt;/li>
&lt;li>&lt;strong>CRC&lt;/strong>: A four-byte CRC calculated on the preceding bytes in the chunk, including the chunk type field and chunk data fields, but not including the length field.&lt;/li>
&lt;/ul>
&lt;p>When encoding a PNG file the library function &lt;em>compress&lt;/em> calls the zlib&amp;rsquo;s compression routines, sets the necessary fields for every chunk (like signatures and CRCs) and writes to the image file opened.&lt;/p>
&lt;h2 id="image-decoding">Image Decoding
&lt;/h2>&lt;p>When decoding a PNG file the library searches all the IDAT chunks in the file, concatenates their data to get the whole zlib datastream, decompresses it to the original pixel data and returns it.&lt;/p></description></item></channel></rss>